{"ast":null,"code":"const speechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\nconst recognition = new speechRecognition();\nrecognition.lang = 'id-ID';\nrecognition.interimResults = true;\nrecognition.maxAlternatives = 1;\nlet transcript = '';\nexport default {\n  data() {\n    return {\n      button: true,\n      result1: null,\n      result2: null\n    };\n  },\n  methods: {\n    startRecord() {\n      recognition.onstart;\n      console.log('Speech recognition service has started');\n      this.button = false;\n    },\n    stopRecord() {\n      recognition.onend;\n      result();\n      console.log('Speech recognition service has stopped');\n      this.button = true;\n    },\n    result() {\n      speechRecognition.onresult = event => {\n        // Create the interim transcript string locally because we don't want it to persist like final transcript\n        let interim_transcript = \"\";\n\n        // Loop through the results from the speech recognition object.\n        for (let i = event.resultIndex; i < event.results.length; ++i) {\n          // If the result item is Final, add it to Final Transcript, Else add it to Interim transcript\n          if (event.results[i].isFinal) {\n            final_transcript += event.results[i][0].transcript;\n          } else {\n            interim_transcript += event.results[i][0].transcript;\n          }\n        }\n\n        // Set the Final franscript and Interim transcript.\n        result1 = final_transcript;\n        result2 = interim_transcript;\n      };\n    }\n  }\n};","map":{"version":3,"names":["speechRecognition","window","SpeechRecognition","webkitSpeechRecognition","recognition","lang","interimResults","maxAlternatives","transcript","data","button","result1","result2","methods","startRecord","onstart","console","log","stopRecord","onend","result","onresult","event","interim_transcript","i","resultIndex","results","length","isFinal","final_transcript"],"sources":["D:\\kuliah\\Sem 4\\Tekmul\\vue-router\\client\\src\\views\\main.vue"],"sourcesContent":["<template>\r\n<head>\r\n  <title> Speech To Text</title>\r\n  <!-- <link rel=\"stylesheet\" href=\"../style/style.css\"> -->\r\n</head>\r\n  <body>\r\n    <h1>Speech to Text</h1>\r\n    <button @click=\"startRecord()\" v-if=\"this.button == true\">Start Recording</button>\r\n    <button @click=\"stopRecord()\" v-if=\"this.button == false\">Stop Recording</button>\r\n    <p >{{ this.result1 }}</p> || <p >{{ this.result1 }}</p>\r\n  </body>\r\n</template>\r\n\r\n\r\n<script>\r\nconst speechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\r\nconst recognition = new speechRecognition();\r\n\r\nrecognition.lang = 'id-ID';\r\nrecognition.interimResults = true;\r\nrecognition.maxAlternatives = 1;\r\n\r\nlet transcript = '';\r\n\r\n\r\nexport default {\r\n  data(){\r\n    return{\r\n      button: true,\r\n      result1: null,\r\n      result2: null\r\n    }\r\n  },\r\n  methods:{\r\n    startRecord(){\r\n      recognition.onstart;\r\n      console.log('Speech recognition service has started');\r\n      this.button = false;\r\n    },\r\n    stopRecord(){\r\n      recognition.onend;\r\n      result();\r\n      console.log('Speech recognition service has stopped');\r\n      this.button = true;\r\n    },\r\n    result(){\r\n      speechRecognition.onresult = (event) => {\r\n      // Create the interim transcript string locally because we don't want it to persist like final transcript\r\n      let interim_transcript = \"\";\r\n\r\n      // Loop through the results from the speech recognition object.\r\n      for (let i = event.resultIndex; i < event.results.length; ++i) {\r\n        // If the result item is Final, add it to Final Transcript, Else add it to Interim transcript\r\n        if (event.results[i].isFinal) {\r\n          final_transcript += event.results[i][0].transcript;\r\n        } else {\r\n          interim_transcript += event.results[i][0].transcript;\r\n        }\r\n      }\r\n\r\n      // Set the Final franscript and Interim transcript.\r\n      result1 = final_transcript;\r\n      result2 = interim_transcript;\r\n};\r\n    }\r\n  }  \r\n}\r\n\r\n</script>\r\n  "],"mappings":"AAeA,MAAMA,iBAAgB,GAAIC,MAAM,CAACC,iBAAgB,IAAKD,MAAM,CAACE,uBAAuB;AACpF,MAAMC,WAAU,GAAI,IAAIJ,iBAAiB,EAAE;AAE3CI,WAAW,CAACC,IAAG,GAAI,OAAO;AAC1BD,WAAW,CAACE,cAAa,GAAI,IAAI;AACjCF,WAAW,CAACG,eAAc,GAAI,CAAC;AAE/B,IAAIC,UAAS,GAAI,EAAE;AAGnB,eAAe;EACbC,IAAIA,CAAA,EAAE;IACJ,OAAM;MACJC,MAAM,EAAE,IAAI;MACZC,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE;IACX;EACF,CAAC;EACDC,OAAO,EAAC;IACNC,WAAWA,CAAA,EAAE;MACXV,WAAW,CAACW,OAAO;MACnBC,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;MACrD,IAAI,CAACP,MAAK,GAAI,KAAK;IACrB,CAAC;IACDQ,UAAUA,CAAA,EAAE;MACVd,WAAW,CAACe,KAAK;MACjBC,MAAM,EAAE;MACRJ,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;MACrD,IAAI,CAACP,MAAK,GAAI,IAAI;IACpB,CAAC;IACDU,MAAMA,CAAA,EAAE;MACNpB,iBAAiB,CAACqB,QAAO,GAAKC,KAAK,IAAK;QACxC;QACA,IAAIC,kBAAiB,GAAI,EAAE;;QAE3B;QACA,KAAK,IAAIC,CAAA,GAAIF,KAAK,CAACG,WAAW,EAAED,CAAA,GAAIF,KAAK,CAACI,OAAO,CAACC,MAAM,EAAE,EAAEH,CAAC,EAAE;UAC7D;UACA,IAAIF,KAAK,CAACI,OAAO,CAACF,CAAC,CAAC,CAACI,OAAO,EAAE;YAC5BC,gBAAe,IAAKP,KAAK,CAACI,OAAO,CAACF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAChB,UAAU;UACpD,OAAO;YACLe,kBAAiB,IAAKD,KAAK,CAACI,OAAO,CAACF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAChB,UAAU;UACtD;QACF;;QAEA;QACAG,OAAM,GAAIkB,gBAAgB;QAC1BjB,OAAM,GAAIW,kBAAkB;MAClC,CAAC;IACG;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}